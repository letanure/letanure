---
title: "From WTF to SOLID Code: Part 3A - SOLID Principles"
date: 2025-07-20
summary: "Master the big-picture principles that make systems scalable and maintainable. The final part of our programming principles series covers SOLID, CQRS, and architectural patterns."
tags: [programming, principles, clean-code, architecture, solid, design-patterns]
---

# From WTF to SOLID Code: Part 3A - SOLID Principles

In [Part 1](./understand-acronym-spaghetti-wtf-to-solid-code), we covered **Tier 1** fundamentals, and in [Part 2](./wtf-to-solid-code-part-2-quality-principles), we explored **Tier 2** quality principles.

**Tier 3** principles are about the big picture - how to structure systems that can grow and evolve over time. While SOLID comes from object-oriented programming, these patterns apply to React components, Node.js modules, and modern JavaScript applications.

## SOLID Principles Deep Dive

SOLID is the foundation of object-oriented architecture. These 5 principles work together to create flexible, maintainable systems.

### SOLID
*Also known as: The 5 OOP Principles*

**Definition:** 5 OOP principles for clean architecture: **S**ingle Responsibility, **O**pen/Closed, **L**iskov Substitution, **I**nterface Segregation, **D**ependency Inversion.

**Why it matters:** Creates flexible, maintainable systems that can evolve without breaking existing code.

**When to break this rule:** Simple applications where the overhead of full SOLID compliance outweighs the benefits.

**Note:** We covered **S**ingle Responsibility Principle in [Part 1](./understand-acronym-spaghetti-wtf-to-solid-code). Here are the other 4 principles:

#### Open/Closed Principle (OCP)
*Open for extension, closed for modification*

**Simple explanation:** You should be able to add new features without changing existing code.

```typescript
// ❌ Must modify existing code to add new behavior
const WelcomeNotification = ({ user }: { user: User }) => {
  const getMessage = () => {
    if (user.type === 'premium') {
      return 'Welcome Premium User!';
    } else if (user.type === 'basic') {
      return 'Welcome!';
    }
    // To add 'enterprise' - must modify this function
  };
  
  return <div>{getMessage()}</div>;
};

// ❌ Node.js API - must modify to add new user types
app.post('/api/welcome', (req, res) => {
  const { user } = req.body;
  
  if (user.type === 'premium') {
    // Premium welcome logic
  } else if (user.type === 'basic') {
    // Basic welcome logic
  }
  // To add 'enterprise' - must modify this endpoint
});

// ✅ Can extend without modifying existing code
// strategies/welcomeStrategies.ts
const welcomeStrategies = {
  premium: (user: User) => `Welcome ${user.name}! Enjoy your premium features.`,
  basic: (user: User) => `Welcome ${user.name}!`,
  enterprise: (user: User) => `Welcome ${user.name}! Your enterprise dashboard awaits.`
};

const WelcomeNotification = ({ user }: { user: User }) => {
  const strategy = welcomeStrategies[user.type] || welcomeStrategies.basic;
  return <div>{strategy(user)}</div>;
};

// ✅ Node.js API - extensible without modification
// services/welcomeService.ts
const welcomeHandlers = {
  premium: async (user: User) => {
    await emailService.sendPremiumWelcome(user);
    await analyticsService.track('premium_user_welcome', user.id);
  },
  basic: async (user: User) => {
    await emailService.sendBasicWelcome(user);
  }
};

app.post('/api/welcome', async (req, res) => {
  const { user } = req.body;
  const handler = welcomeHandlers[user.type] || welcomeHandlers.basic;
  await handler(user);
  res.json({ success: true });
});
```

#### Liskov Substitution Principle (LSP)
*Subtypes must be substitutable for their base types*

**Simple explanation:** If you have different implementations of the same interface, you should be able to swap them without breaking anything.

```typescript
// ❌ Different components with inconsistent interfaces
const BasicButton = ({ label, onClick }: { label: string; onClick: () => void }) => {
  return <button onClick={onClick}>{label}</button>;
};

const PremiumButton = ({ 
  label, 
  onClick, 
  theme 
}: { 
  label: string; 
  onClick: (event: any) => void; // Different signature!
  theme: string; // Extra required prop!
}) => {
  return <button className={theme} onClick={onClick}>{label}</button>;
};

// ❌ Node.js services with inconsistent interfaces
const basicEmailService = {
  send: (to: string, subject: string, body: string) => {
    // Send basic email
  }
};

const premiumEmailService = {
  send: (to: string, subject: string, body: string, priority: 'high' | 'low') => {
    // Requires extra parameter - breaks substitution
  }
};

// ✅ Consistent interfaces - can be swapped freely
interface ButtonProps {
  label: string;
  onClick: () => void;
  theme?: string;
}

const BasicButton = ({ label, onClick, theme = 'default' }: ButtonProps) => {
  return <button className={theme} onClick={onClick}>{label}</button>;
};

const PremiumButton = ({ label, onClick, theme = 'premium' }: ButtonProps) => {
  return <button className={theme} onClick={onClick}>{label}</button>;
};

// ✅ Node.js services with consistent interfaces
interface EmailService {
  send(to: string, subject: string, body: string, options?: any): Promise<void>;
}

const basicEmailService: EmailService = {
  send: async (to, subject, body) => {
    // Send basic email
  }
};

const premiumEmailService: EmailService = {
  send: async (to, subject, body, options = {}) => {
    // Send premium email with optional features
  }
};

// ✅ Can swap services without changing calling code
const sendWelcomeEmail = async (emailService: EmailService, user: User) => {
  await emailService.send(user.email, 'Welcome!', 'Welcome to our platform');
};
```

#### Interface Segregation Principle (ISP)
*Clients shouldn't depend on interfaces they don't use*

**Simple explanation:** Don't force a component or function to depend on methods it doesn't need. Make small, focused interfaces instead of big ones.

```typescript
// ❌ Fat interface - UserProfile component forced to depend on methods it doesn't use
interface UserService {
  getUser(id: string): Promise<User>;
  createUser(data: any): Promise<User>;
  deleteUser(id: string): Promise<void>;
  generateReport(): Promise<string>;
  sendNotifications(): Promise<void>;
  updateUserPreferences(id: string, prefs: any): Promise<void>;
}

const UserProfile = ({ userId, userService }: { 
  userId: string; 
  userService: UserService; // Depends on methods it doesn't need
}) => {
  const [user, setUser] = useState(null);
  
  useEffect(() => {
    userService.getUser(userId).then(setUser); // Only uses getUser
  }, [userId]);
  
  return <div>{user?.name}</div>;
};

// ❌ Node.js - fat service interface
const userController = {
  getProfile: async (req, res, userService: UserService) => {
    const user = await userService.getUser(req.params.id); // Only needs getUser
    res.json(user);
  }
};

// ✅ Focused interfaces - components only depend on what they need
interface UserReader {
  getUser(id: string): Promise<User>;
}

interface UserWriter {
  createUser(data: any): Promise<User>;
  updateUser(id: string, data: any): Promise<User>;
  deleteUser(id: string): Promise<void>;
}

interface UserReporter {
  generateReport(): Promise<string>;
}

const UserProfile = ({ userId, userReader }: { 
  userId: string; 
  userReader: UserReader; // Only depends on reading
}) => {
  const [user, setUser] = useState(null);
  
  useEffect(() => {
    userReader.getUser(userId).then(setUser); // Clear dependency
  }, [userId]);
  
  return <div>{user?.name}</div>;
};

// ✅ Node.js - focused service dependencies
const userController = {
  getProfile: async (req, res, userReader: UserReader) => {
    const user = await userReader.getUser(req.params.id);
    res.json(user);
  },
  
  updateProfile: async (req, res, userWriter: UserWriter) => {
    const user = await userWriter.updateUser(req.params.id, req.body);
    res.json(user);
  }
};

// ✅ Custom hooks can be focused too
const useUserProfile = (userId: string) => {
  // Only needs reading capability
  return useQuery(['user', userId], () => userService.getUser(userId));
};

const useUserMutations = () => {
  // Only needs writing capability  
  return useMutation((data: any) => userService.createUser(data));
};
```

#### Dependency Inversion Principle (DIP)
*Depend on abstractions, not concretions*

**Simple explanation:** Don't depend on specific implementations. Depend on interfaces so you can easily swap out different implementations.

**Why "inversion"?** Traditionally, high-level modules (business logic) depend on low-level modules (database, file system). DIP inverts this - both should depend on abstractions.

```typescript
// ❌ Traditional dependency flow - high-level depends on low-level
const UserService = () => {
  const saveUser = async (user: User) => {
    // Direct dependency on specific implementations
    await fetch('/api/mysql/users', { // Hard-coded to MySQL API
      method: 'POST',
      body: JSON.stringify(user)
    });
    
    console.log('User saved'); // Hard-coded to console logging
    // Hard to test, hard to change database or logger
  };
  
  return { saveUser };
};

// ❌ React component with hard-coded dependencies
const UserForm = () => {
  const [user, setUser] = useState({});
  
  const handleSubmit = async () => {
    // Direct dependency on specific API endpoint
    await fetch('/api/users', {
      method: 'POST',
      body: JSON.stringify(user)
    });
    
    // Direct dependency on specific analytics service
    gtag('event', 'user_created', { user_id: user.id });
    
    // Hard to test, hard to swap implementations
  };
  
  return <form onSubmit={handleSubmit}>...</form>;
};

// ✅ Inverted dependencies - both depend on abstractions
interface Database {
  save(user: User): Promise<void>;
}

interface Logger {
  log(message: string): void;
}

interface AnalyticsService {
  track(event: string, data: any): void;
}

// ✅ High-level business logic depends on abstractions
const createUserService = (db: Database, logger: Logger) => {
  const saveUser = async (user: User) => {
    await db.save(user); // Depends on abstraction
    logger.log('User saved'); // Depends on abstraction
    // Easy to test with mocks, easy to swap implementations
  };
  
  return { saveUser };
};

// ✅ React component depends on abstractions
const UserForm = ({ 
  userService, 
  analytics 
}: { 
  userService: { saveUser: (user: User) => Promise<void> };
  analytics: AnalyticsService;
}) => {
  const [user, setUser] = useState({});
  
  const handleSubmit = async () => {
    await userService.saveUser(user); // Depends on abstraction
    analytics.track('user_created', { user_id: user.id }); // Depends on abstraction
    // Easy to test with mocks, easy to swap implementations
  };
  
  return <form onSubmit={handleSubmit}>...</form>;
};

// ✅ Low-level implementations depend on abstractions
const mysqlDatabase: Database = {
  save: async (user: User) => {
    await fetch('/api/mysql/users', {
      method: 'POST',
      body: JSON.stringify(user)
    });
  }
};

const consoleLogger: Logger = {
  log: (message: string) => console.log(message)
};

const gtagAnalytics: AnalyticsService = {
  track: (event: string, data: any) => {
    gtag('event', event, data);
  }
};

// ✅ Dependency injection - wire everything together
const userService = createUserService(mysqlDatabase, consoleLogger);

// ✅ Can easily swap to different implementations
const testUserService = createUserService(
  { save: async () => {} }, // Mock database
  { log: () => {} }         // Mock logger
);

// ✅ In your app component
const App = () => {
  return (
    <UserForm 
      userService={userService} 
      analytics={gtagAnalytics}
    />
  );
};
```

**Benefits:**
- **Testability**: Inject mocks for testing
- **Flexibility**: Swap implementations without changing business logic
- **Maintainability**: Changes to low-level modules don't affect high-level modules

**Common Pitfall:** Trying to apply all SOLID principles at once instead of gradually refactoring towards them as the system grows.

---

## Summary

**SOLID principles** are the foundation of good object-oriented design. They work together to create systems that are:
- **Flexible**: Easy to extend and modify
- **Testable**: Components can be tested in isolation
- **Maintainable**: Changes don't ripple through the entire system

Start with **Single Responsibility** and **Dependency Inversion** - these give you the biggest bang for your buck.

**Coming next:** [Part 3B](./wtf-to-solid-code-part-3b-cqrs-and-hexagonal) will cover advanced architecture patterns like CQRS and Hexagonal Architecture.

Remember: **good architecture is not about following every pattern - it's about making intentional choices that serve your specific needs.**
---
title: "From WTF to SOLID Code: Part 2 - The Quality Principles"
date: 2025-07-19
summary: "Level up your code quality with principles like Pure Functions, Immutability, and Principle of Least Surprise. The second part of our programming principles series."
tags: [programming, principles, clean-code, best-practices, code-quality]
---

# From WTF to SOLID Code: Part 2 - The Quality Principles

In [Part 1](./understand-acronym-spaghetti-wtf-to-solid-code), we covered the **Tier 1** fundamentals: SRP, DRY, KISS, YAGNI, Fail Fast, GIGO, and Separation of Concerns.

**Tier 2** principles take your code quality from "it works" to "it works well."

## Tier 2 — Code Quality & Safety

These are best practices that make your code more predictable, testable, and maintainable.

### Pure Functions

**Definition:** A function that always returns the same output for the same input and has no side effects.

**Why it matters:** Predictable, testable, and easy to reason about. No hidden dependencies or surprises.

**When to break this rule:** When you need to interact with the outside world (APIs, files, databases) or when performance requires caching/memoization.

**Bad Example:**
```typescript
// ❌ Simple function - has side effects and depends on external state
let counter = 0;
const addToCounter = (value: number) => {
  counter += value; // Side effect - modifies external state
  console.log('Added:', value); // Side effect - I/O operation
  return counter; // Output depends on external state
};

// ❌ React component - impure calculations
const ProductCard = ({ product }: { product: Product }) => {
  const [clickCount, setClickCount] = useState(0);
  
  const calculateDiscount = () => {
    const now = new Date(); // Non-deterministic - depends on current time
    const isWeekend = now.getDay() === 0 || now.getDay() === 6;
    setClickCount(prev => prev + 1); // Side effect - modifies state
    return isWeekend ? 0.2 : 0.1;
  };
  
  return <div>Price: ${product.price * (1 - calculateDiscount())}</div>;
};

// ❌ Utility function - impure due to external dependencies
const formatUserName = (user: User) => {
  const settings = getGlobalSettings(); // External dependency
  localStorage.setItem('lastUser', user.id); // Side effect
  
  return settings.showFullName 
    ? `${user.firstName} ${user.lastName}`
    : user.firstName;
};
```

**Good Example:**
```typescript
// ✅ Simple function - pure and predictable
const add = (a: number, b: number): number => {
  return a + b; // Same input always produces same output
};

// ✅ React component - pure calculations
const ProductCard = ({ product, isWeekend }: { product: Product; isWeekend: boolean }) => {
  const calculateDiscount = (isWeekend: boolean) => {
    return isWeekend ? 0.2 : 0.1; // Pure - same input, same output
  };
  
  const discountedPrice = product.price * (1 - calculateDiscount(isWeekend));
  
  return <div>Price: ${discountedPrice}</div>;
};

// ✅ Utility function - pure with explicit dependencies
const formatUserName = (user: User, showFullName: boolean): string => {
  return showFullName 
    ? `${user.firstName} ${user.lastName}`
    : user.firstName;
};

// Side effects handled separately
const saveUserAction = (userId: string) => {
  localStorage.setItem('lastUser', userId);
};
```

**Common Pitfall:** Mixing pure logic with I/O operations, making functions hard to test and unpredictable.

---

### Immutability

**Definition:** Don't mutate objects — return new ones instead. Data structures should not be changed after creation.

**Why it matters:** Prevents bugs from unexpected changes, makes code easier to reason about, enables better performance optimizations.

**When to break this rule:** Performance-critical code where creating new objects is too expensive, or when working with large datasets where mutation is necessary.

**Bad Example:**
```typescript
// ❌ Simple function - mutates input array
const addItemToCart = (cart: CartItem[], item: CartItem) => {
  cart.push(item); // Mutates the original array
  return cart;
};

// ❌ React component - direct state mutation
const ShoppingCart = () => {
  const [cart, setCart] = useState<CartItem[]>([]);
  
  const addItem = (item: CartItem) => {
    cart.push(item); // Mutates state directly
    setCart(cart); // React won't detect the change
  };
  
  const updateQuantity = (itemId: string, quantity: number) => {
    const item = cart.find(i => i.id === itemId);
    if (item) {
      item.quantity = quantity; // Mutates nested object
      setCart(cart);
    }
  };
  
  return <div>{cart.map(item => <CartItem key={item.id} item={item} />)}</div>;
};

// ❌ User profile update - mutates user object
const updateUserProfile = (user: User, updates: Partial<User>) => {
  user.name = updates.name || user.name; // Mutates original
  user.email = updates.email || user.email; // Mutates original
  user.updatedAt = new Date(); // Mutates original
  return user;
};
```

**Good Example:**
```typescript
// ✅ Simple function - returns new array
const addItemToCart = (cart: CartItem[], item: CartItem): CartItem[] => {
  return [...cart, item]; // Creates new array
};

// ✅ React component - immutable state updates
const ShoppingCart = () => {
  const [cart, setCart] = useState<CartItem[]>([]);
  
  const addItem = (item: CartItem) => {
    setCart(prevCart => [...prevCart, item]); // Creates new array
  };
  
  const updateQuantity = (itemId: string, quantity: number) => {
    setCart(prevCart => 
      prevCart.map(item => 
        item.id === itemId 
          ? { ...item, quantity } // Creates new object
          : item
      )
    );
  };
  
  return <div>{cart.map(item => <CartItem key={item.id} item={item} />)}</div>;
};

// ✅ User profile update - returns new user object
const updateUserProfile = (user: User, updates: Partial<User>): User => {
  return {
    ...user,
    ...updates,
    updatedAt: new Date()
  }; // Creates completely new object
};
```

**Common Pitfall:** Thinking immutability means you can't change data at all, instead of creating new versions of data structures.

---

### Principle of Least Surprise

**Definition:** Code should behave as people intuitively expect. Functions, variables, interfaces, and folder structures should do what their names suggest.

**Why it matters:** Reduces cognitive load, makes code self-documenting, prevents bugs from misunderstanding.

**When to break this rule:** When following domain-specific conventions that might seem unusual but are standard in that field.

**Bad Example:**
```typescript
// ❌ Simple function - misleading name and behavior
const getUser = (id: string) => {
  const user = database.findUser(id);
  user.lastAccessed = new Date(); // Surprise! It modifies data
  analytics.track('user_accessed', { userId: id }); // Surprise! It tracks events
  return user;
};

// ❌ React component - unexpected state changes
const UserList = ({ users }: { users: User[] }) => {
  const [searchTerm, setSearchTerm] = useState('');
  
  const filteredUsers = users.filter(user => {
    // Surprise! Filtering also sorts and modifies original data
    user.displayName = user.firstName + ' ' + user.lastName;
    return user.name.includes(searchTerm);
  }).sort((a, b) => a.name.localeCompare(b.name));
  
  return (
    <div>
      <input onChange={e => setSearchTerm(e.target.value)} />
      {filteredUsers.map(user => <div key={user.id}>{user.displayName}</div>)}
    </div>
  );
};

// ❌ Folder structure - misleading organization
/*
src/
├── helpers/
│   ├── userValidation.ts  // Actually business logic, not helpers
│   ├── paymentService.ts  // Actually a service, not a helper
│   └── Button.tsx         // Surprise! UI component in helpers
├── utils/
│   ├── ApiClient.ts       // Actually a service, not a utility
│   ├── formatDate.ts      // Actually a utility ✓
│   └── UserModel.ts       // Actually a model, not a utility
├── app/
│   ├── LoginPage.tsx      // Surprise! Page component in app folder
│   └── database.ts        // Surprise! Infrastructure in app folder
└── pages/
    ├── userHelpers.ts     // Surprise! Helper functions in pages
    └── api.ts             // Surprise! API client in pages
*/

// ❌ Utility function - confusing boolean logic
const isUserActive = (user: User): boolean => {
  // Surprise! Returns false for active users
  return user.status === 'inactive' || user.lastLogin < Date.now() - 30 * 24 * 60 * 60 * 1000;
};
```

**Good Example:**
```typescript
// ✅ Simple function - does exactly what the name says
const getUser = (id: string): User => {
  return database.findUser(id); // Just gets the user
};

// Side effects are separate and explicit
const trackUserAccess = (userId: string) => {
  analytics.track('user_accessed', { userId });
};

const updateUserLastAccessed = (userId: string) => {
  database.updateUser(userId, { lastAccessed: new Date() });
};

// ✅ React component - clear and predictable
const UserList = ({ users }: { users: User[] }) => {
  const [searchTerm, setSearchTerm] = useState('');
  
  const filteredUsers = users
    .filter(user => user.name.includes(searchTerm))
    .map(user => ({
      ...user,
      displayName: `${user.firstName} ${user.lastName}`
    }))
    .sort((a, b) => a.name.localeCompare(b.name));
  
  return (
    <div>
      <input onChange={e => setSearchTerm(e.target.value)} />
      {filteredUsers.map(user => <div key={user.id}>{user.displayName}</div>)}
    </div>
  );
};

// ✅ Folder structure - clear organization
/*
src/
├── components/
│   ├── UserList.tsx
│   └── Button.tsx
├── services/
│   ├── paymentService.ts
│   ├── userService.ts
│   └── apiClient.ts
├── utils/
│   ├── dateHelpers.ts
│   └── formatters.ts
├── models/
│   └── UserModel.ts
├── business/
│   └── userValidation.ts
└── pages/
    └── LoginPage.tsx
*/

// ✅ Utility function - clear boolean logic
const isUserActive = (user: User): boolean => {
  return user.status === 'active' && user.lastLogin > Date.now() - 30 * 24 * 60 * 60 * 1000;
};
```

**Common Pitfall:** Using names that don't accurately describe what the code actually does.

---

### Design by Contract

**Definition:** Define input/output conditions clearly. Specify what a function expects (preconditions) and what it guarantees (postconditions).

**Why it matters:** Makes function behavior explicit, catches bugs early, improves documentation and testing.

**When to break this rule:** Simple, obvious functions where the contract is self-evident from the name and types.

**Bad Example:**
```typescript
// ❌ Simple function - no clear contract
const calculateDiscount = (price: any, userType: any) => {
  // What happens if price is negative? What userTypes are valid?
  if (userType === 'premium') return price * 0.8;
  if (userType === 'regular') return price * 0.9;
  return price; // Silent fallback - no indication this can happen
};

// ❌ React component - unclear expectations
const UserProfile = ({ user }: { user: any }) => {
  // What if user is null? What properties are required?
  return (
    <div>
      <h1>{user.name}</h1>
      <p>{user.email}</p>
      <p>Member since: {user.joinDate.toLocaleDateString()}</p>
    </div>
  );
};

// ❌ API function - vague contract
const updateUser = async (id: string, data: any) => {
  // What fields can be updated? What validations apply?
  // What errors can occur? What does success look like?
  const response = await fetch(`/api/users/${id}`, {
    method: 'PUT',
    body: JSON.stringify(data)
  });
  return response.json();
};
```

**Good Example:**
```typescript
// ✅ Simple function - explicit contract
const calculateDiscount = (price: number, userType: 'premium' | 'regular'): number => {
  // Preconditions: price >= 0, userType must be 'premium' or 'regular'
  if (price < 0) throw new Error('Price must be non-negative');
  
  // Postconditions: returns discounted price (0.8x for premium, 0.9x for regular)
  if (userType === 'premium') return price * 0.8;
  if (userType === 'regular') return price * 0.9;
  
  // This line should never be reached due to TypeScript types
  throw new Error(`Invalid user type: ${userType}`);
};

// ✅ React component - clear interface
interface UserProfileProps {
  user: {
    name: string;
    email: string;
    joinDate: Date;
  };
}

const UserProfile = ({ user }: UserProfileProps) => {
  // Contract: user object must have name, email, and joinDate
  // Guarantees: renders user information or throws error
  return (
    <div>
      <h1>{user.name}</h1>
      <p>{user.email}</p>
      <p>Member since: {user.joinDate.toLocaleDateString()}</p>
    </div>
  );
};

// ✅ API function - explicit contract
interface UpdateUserRequest {
  name?: string;
  email?: string;
}

interface UpdateUserResponse {
  success: boolean;
  user?: User;
  error?: string;
}

const updateUser = async (id: string, data: UpdateUserRequest): Promise<UpdateUserResponse> => {
  // Preconditions: id must be valid UUID, data must contain at least one field
  if (!id || typeof id !== 'string') {
    return { success: false, error: 'Invalid user ID' };
  }
  
  if (!data.name && !data.email) {
    return { success: false, error: 'At least one field must be provided' };
  }
  
  try {
    const response = await fetch(`/api/users/${id}`, {
      method: 'PUT',
      body: JSON.stringify(data)
    });
    
    if (!response.ok) {
      return { success: false, error: 'Failed to update user' };
    }
    
    const user = await response.json();
    return { success: true, user };
  } catch (error) {
    return { success: false, error: 'Network error' };
  }
};
```

**Common Pitfall:** Assuming callers will know what inputs are valid and what outputs to expect without explicit documentation.

---

### Explicit is better than implicit

**Definition:** Be clear rather than clever. Make your intentions obvious instead of relying on hidden assumptions or magic.

**Why it matters:** Code is read more often than it's written. Explicit code is easier to understand, debug, and maintain.

**When to break this rule:** When well-established conventions make implicit behavior clearer than explicit (like `map` or `filter` operations).

**Bad Example:**
```typescript
// ❌ Simple function - relies on implicit behavior
const processUsers = (users: User[]) => {
  return users
    .filter(u => u.active && u.level > 2) // What does level > 2 mean?
    .map(u => ({ ...u, bonus: u.sales * 0.1 })) // Why 0.1? What's the logic?
    .sort((a, b) => b.bonus - a.bonus); // Implicit descending sort
};

// ❌ React component - implicit dependencies and logic
const ProductList = ({ category }: { category: string }) => {
  const [products, setProducts] = useState([]);
  
  useEffect(() => {
    // Implicit API structure and error handling
    fetch(`/api/products?cat=${category}`)
      .then(res => res.json())
      .then(setProducts);
  }, [category]);
  
  return (
    <div>
      {products
        .filter(p => p.price > 0) // Implicit business rule
        .map(p => (
          <div key={p.id}>
            <h3>{p.name}</h3>
            <p>${p.price}</p>
            {p.stock < 5 && <span style={{ color: 'red' }}>Low stock!</span>} {/* Magic number */}
          </div>
        ))}
    </div>
  );
};

// ❌ Configuration - implicit settings
const API_CONFIG = {
  baseUrl: process.env.API_URL || 'https://api.example.com',
  timeout: 5000, // Magic number - why 5000?
  retries: 3, // Magic number - why 3?
};
```

**Good Example:**
```typescript
// ✅ Simple function - explicit business logic
const SENIOR_USER_LEVEL = 2;
const COMMISSION_RATE = 0.1;

const processUsers = (users: User[]) => {
  const activeSeniorUsers = users.filter(user => 
    user.active && user.level > SENIOR_USER_LEVEL
  );
  
  const usersWithBonus = activeSeniorUsers.map(user => ({
    ...user,
    bonus: calculateCommission(user.sales)
  }));
  
  return sortByBonusDescending(usersWithBonus);
};

const calculateCommission = (sales: number): number => {
  return sales * COMMISSION_RATE;
};

const sortByBonusDescending = (users: User[]): User[] => {
  return users.sort((a, b) => b.bonus - a.bonus);
};

// ✅ React component - explicit dependencies and logic
const LOW_STOCK_THRESHOLD = 5;

const ProductList = ({ category }: { category: string }) => {
  const [products, setProducts] = useState<Product[]>([]);
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);
  
  useEffect(() => {
    const fetchProducts = async () => {
      setLoading(true);
      setError(null);
      
      try {
        const response = await fetch(`/api/products?category=${category}`);
        if (!response.ok) {
          throw new Error(`Failed to fetch products: ${response.statusText}`);
        }
        const data = await response.json();
        setProducts(data);
      } catch (err) {
        setError(err instanceof Error ? err.message : 'Unknown error');
      } finally {
        setLoading(false);
      }
    };
    
    fetchProducts();
  }, [category]);
  
  const availableProducts = products.filter(isProductAvailable);
  
  if (loading) return <div>Loading products...</div>;
  if (error) return <div>Error: {error}</div>;
  
  return (
    <div>
      {availableProducts.map(product => (
        <div key={product.id}>
          <h3>{product.name}</h3>
          <p>${product.price}</p>
          {isLowStock(product) && (
            <span style={{ color: 'red' }}>Low stock!</span>
          )}
        </div>
      ))}
    </div>
  );
};

const isProductAvailable = (product: Product): boolean => {
  return product.price > 0;
};

const isLowStock = (product: Product): boolean => {
  return product.stock < LOW_STOCK_THRESHOLD;
};

// ✅ Configuration - explicit settings with documentation
const API_CONFIG = {
  baseUrl: process.env.API_URL || 'https://api.example.com',
  timeout: 5000, // 5 seconds - balance between user experience and server load
  retries: 3, // 3 attempts - enough to handle transient failures without overloading
  retryDelay: 1000, // 1 second between retries
} as const;
```

**Common Pitfall:** Using magic numbers, unexplained business rules, or clever one-liners that require mental parsing to understand.

---

## Summary

**Tier 2** principles help you write code that's not just functional, but robust and reliable. They're the difference between code that works today and code that works in six months when you (or someone else) needs to modify it.

**Coming next:** Tier 3 (System/Architecture Level) will cover the big-picture principles for building scalable systems.

Remember: **good code is not about showing off how smart you are - it's about making life easier for the next person who reads it (including future you).**
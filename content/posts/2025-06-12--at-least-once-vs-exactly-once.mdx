---
title: At-Least-Once vs. Exactly-Once: What Real Systems Actually Guarantee
date: 2025-06-12
summary: Understand the difference between at-least-once and exactly-once delivery. Learn why most real-world systems go with retries and idempotency instead of costly guarantees.
tags: ['system design', 'backend', 'queues', 'supabase', 'jobs']
---

# ðŸ“¦ At-Least-Once vs. Exactly-Once: What Real Systems Actually Guarantee

When your system performs a critical action â€” like sending a webhook, delivering a job, or recording a payment â€” ask yourself:

> **How many times can this action happen?**

---

## âœ… At-Least-Once

**The system guarantees the action will happen**  
But it might happen **more than once**

- Common in message queues: RabbitMQ, Kafka, Supabase Realtime
- Works well **if your action is idempotent**
- Simple to retry on failure

### Example

```ts
// Supabase Function receives webhook
export async function POST(req) {
  const event = await req.json();

  // âœ… Make this idempotent
  const alreadyHandled = await supabase
    .from('webhook_logs')
    .select('*')
    .eq('event_id', event.id)
    .maybeSingle();

  if (alreadyHandled) return new Response('Duplicate', { status: 200 });

  await supabase.from('webhook_logs').insert({
    event_id: event.id,
    payload: event,
  });

  await processEvent(event);
  return new Response('OK');
}
```

If the event is delivered twice, itâ€™s fine â€” only one result is stored.

---

## âŒ Exactly-Once

**The action happens one time â€” and never again.**

Sounds great, but:

- Itâ€™s **very hard** to guarantee in real systems
- Requires coordination across retries, state, and networking
- Slow, complex, and often unnecessary

Even Stripe, Kafka, and AWS **donâ€™t do this by default**  
They rely on **at-least-once + idempotency**

---

## ðŸ§  Why it matters

Youâ€™ll hit this problem when:

- Sending webhooks
- Dispatching background jobs
- Sending emails
- Triggering side effects (inventory, receipts, payouts)

You canâ€™t **rely** on the request going through  
You must ask: â€œWhat happens if it goes through again?â€

---

## ðŸ’¡ Design for at-least-once

- Always use **idempotent operations**
- Track job IDs, event IDs, user intents
- Mark â€œalready handledâ€ before side effects run
- Use `upsert`, unique constraints, or logs

---

## ðŸ“Œ Summary

| Delivery Type     | Guarantees            | Real-world Use   |
|-------------------|------------------------|------------------|
| At-Least-Once     | Will happen â‰¥1         | Webhooks, Jobs   |
| Exactly-Once      | Will happen =1         | Rare, expensive  |

Most of the time, aim for:

> âœ… At-least-once delivery  
> âœ… Idempotent handlers  
> âœ… Safe retries

Thatâ€™s how real systems survive.
---
title: How Idempotency Saves Your API from Chaos
date: 2025-06-11
summary: Understand idempotency and how it protects users and developers from accidental duplicate actions in web systems. Includes Supabase and Node.js examples.
tags: ['supabase', 'api', 'webhooks', 'system design', 'nodejs']
---

# ðŸ” Idempotency: Build APIs That Survive the Real World

Idempotency means:

> **Same request, same result â€” no side effects.**

Not â€œdonâ€™t send it twice.â€  
But: â€œSend it twice, and the world stays clean.â€

---

## ðŸ§¨ Real-world problem

Imagine a user tapping **"Confirm Purchase"** on bad Wi-Fi.

- Nothing happens.
- They tap again.
- Now theyâ€™re charged **twice**.

---

## ðŸŒ€ Another common bug: the user reloads the page

Letâ€™s say the app works like this:

1. Page loads â†’ generate `bookingId = uuidv4()`
2. User clicks â€œBookâ€ â†’ request sent
3. But network fails â€” or UI never shows success
4. User **reloads** the page
5. A **new UUID** is generated
6. They click again â†’ **two bookings created**

Even though their intent was the same.  
The app didnâ€™t treat it that way.

---

## âœ… The fix: persist the UUID across reloads

You need to **generate once and reuse** the ID until success.

```ts
// âœ… BookingButton.tsx (client component)
import { useState, useEffect } from 'react';
import { v4 as uuidv4 } from 'uuid';

export function useStableBookingId() {
  const [bookingId, setBookingId] = useState('');

  useEffect(() => {
    const saved = localStorage.getItem('booking-id');
    if (saved) setBookingId(saved);
    else {
      const newId = uuidv4();
      localStorage.setItem('booking-id', newId);
      setBookingId(newId);
    }
  }, []);

  return bookingId;
}
```

After a **successful** booking, you can clear it:

```ts
localStorage.removeItem('booking-id');
```

Now:
- User retries = same UUID
- User reloads = same UUID
- User spams = same UUID

â†’ One booking only.

---

## âœ… Why generate UUID on the client?

Because only the client knows **the moment of intent**.

- The server sees the request later (maybe multiple times)
- The client can **track retries** and **persist intent**

This matches how **Stripe** does it:
- You set the `Idempotency-Key` header
- It can be retried safely by the client or proxy

---

## âœ… Example: booking with Supabase

```ts
// Client sends same bookingId each time
await fetch('/api/book', {
  method: 'PUT',
  headers: { 'Content-Type': 'application/json' },
  body: JSON.stringify({ bookingId }),
});
```

```ts
// Server uses upsert to deduplicate
await supabase
  .from('bookings')
  .upsert(
    { booking_id: bookingId, status: 'confirmed' },
    { onConflict: ['booking_id'] }
  );
```

---

## ðŸ§  Best practices

- Always generate **stable IDs** for critical actions
- Save them in `localStorage`, `cookies`, or session
- Clear after confirmed success
- Donâ€™t trust the network to "just work"

---

## ðŸ“Œ Summary

> Your job isnâ€™t to block duplicates.  
> Your job is to make sure they donâ€™t hurt anyone.

If the user:
- Clicks twice
- Reloads
- Has a network failure

**Will the result still be correct?**  
If yes â€” thatâ€™s idempotency.